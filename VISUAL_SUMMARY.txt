╔══════════════════════════════════════════════════════════════════════════════╗
║         JAVA CLASS LOADING, LINKING, AND FIELD OFFSET CALCULATION            ║
║                          COMPLETE VISUAL SUMMARY                            ║
╚══════════════════════════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════════════════════════╗
║ PHASE 1: COMPILATION (Javac)                                             ║
╚════════════════════════════════════════════════════════════════════════════╝

SimpleExample.java          →    SimpleExample.class (binary)
┌─────────────────────────┐    ┌──────────────────────────────┐
│ public class Example {  │    │ MAGIC: 0xCAFEBABE            │
│   private int myField;  │    │ VERSION: 61 (Java 17)        │
│                         │    │ CONSTANT_POOL_COUNT: 30      │
│   void printField() {   │    │                              │
│     System.out.println  │    │ CONSTANT POOL:               │
│       (myField);        │    │   #1: Methodref ...         │
│   }                     │    │   #7: Fieldref #8.#9        │
│ }                       │    │        (symbolic!)           │
└─────────────────────────┘    │   #8: Class #10             │
                               │   #9: NameAndType #11:#12   │
                               │   #10: Utf8 "SimpleExample" │
                               │   #11: Utf8 "myField"       │
                               │   #12: Utf8 "I"             │
                               │                              │
                               │ FIELDS SECTION:              │
                               │   Field 1: access=0x0002    │
                               │            name_idx=11       │
                               │            desc_idx=12       │
                               │                              │
                               │ METHODS SECTION:             │
                               │   Method: <init>            │
                               │   Method: printField        │
                               │                              │
                               │ (Contains only names/refs)   │
                               └──────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════

╔════════════════════════════════════════════════════════════════════════════╗
║ PHASE 2: CLASS LOADING & LINKING (JVM)                                    ║
╚════════════════════════════════════════════════════════════════════════════╝

STEP 1: LOAD CLASS FILE
SimpleExample.class → Read from disk → Parse structure

STEP 2: PARSE FIELDS & CALCULATE OFFSETS
┌─────────────────────────────────────────────────────────────┐
│ From .class FIELDS section:                                 │
│   myField: name="myField", type="I", size=4 bytes           │
│                                                              │
│ Header size: 12 bytes (class pointer + monitor)             │
│                                                              │
│ Calculate offset:                                            │
│   current_offset = 12                                        │
│   myField.offset = 12                                        │
│   instance_size = 12 + 4 = 16 bytes                         │
│                                                              │
│ ✓ STORED IN CLASS METADATA FOR LATER USE!                   │
└─────────────────────────────────────────────────────────────┘

STEP 3: PARSE METHODS & BYTECODE
┌─────────────────────────────────────────────────────────────┐
│ Method: printField                                           │
│   Bytecode: [0xAA, 0xB4, 0x00, 0x07, 0xB6, 0x00, 0x13...] │
│   max_stack: 2                                              │
│   max_locals: 1                                             │
│   bytecode_offsets: 0, 1, 4, 7, 8 (position of instructions)│
└─────────────────────────────────────────────────────────────┘

STEP 4: RESOLVE CONSTANT POOL ENTRIES
┌─────────────────────────────────────────────────────────────┐
│ BEFORE LINKING:                                             │
│   Entry #7 (Fieldref) = "class_index=8, name_and_type=9"   │
│   (Still symbolic - just numbers)                           │
│                                                              │
│ AFTER LINKING:                                              │
│   Entry #7 (Fieldref) = {                                   │
│     resolved_class: 0x7f8c92c50000 → SimpleExample.class   │
│     resolved_field: 0x7f8c92c50080 → Field "myField"       │
│     field_offset: 12  ← KEY VALUE!                          │
│     resolved: true                                          │
│   }                                                         │
│                                                              │
│ ✓ READY FOR FAST EXECUTION!                                │
└─────────────────────────────────────────────────────────────┘

STEP 5: BUILD VIRTUAL METHOD TABLE
┌─────────────────────────────────────────────────────────────┐
│ VTable for SimpleExample:                                    │
│   [0] → Object.equals                                        │
│   [1] → Object.hashCode                                      │
│   ...                                                        │
│   [11] → SimpleExample.printField  ← New method             │
└─────────────────────────────────────────────────────────────┘

RESULT: Class Object in Memory
┌──────────────────────────────────────────────────────────────┐
│ SimpleExample.class @ 0x7f8c92c50000                         │
│                                                               │
│ className: "SimpleExample"                                   │
│ instance_size: 16 bytes     ← CALCULATED                    │
│ fields[0]: {                                                 │
│   name: "myField"                                            │
│   offset: 12                ← CALCULATED                    │
│   type: int                                                  │
│ }                                                            │
│ methods[]: [<init>, printField]                             │
│ vtable[]: [Object methods..., printField]                   │
│ constant_pool[]: [resolved entries]                         │
└──────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════

╔════════════════════════════════════════════════════════════════════════════╗
║ PHASE 3: INSTANCE CREATION (new SimpleExample())                          ║
╚════════════════════════════════════════════════════════════════════════════╝

STEP 1: ALLOCATE MEMORY
  Size: instance_size = 16 bytes
  Address: 0x7f8e12345678

  Memory (initial): [???? ???? ???? ????]

STEP 2: INITIALIZE OBJECT HEADER
  Offset 0-7: Class pointer → 0x7f8c92c50000
  Offset 8-11: Monitor → 0

  Memory: [CLASS POINTER .. | MONITOR ...]

STEP 3: INITIALIZE FIELDS (using offsets!)
  For myField (offset=12):
    Address = 0x7f8e12345678 + 12 = 0x7f8e1234568C
    Value = 0 (default for int)

  Memory: [CLASS POINTER .. | MONITOR ... | MYFIELD=0]

STEP 4: CALL CONSTRUCTOR
  If constructor exists, execute it
  It may assign values to fields

RESULT: Instance in Memory
┌──────────────────────────────────────────┐
│ Instance @ 0x7f8e12345678 (16 bytes)    │
├──────────────────────────────────────────┤
│ Offset 0-7:   Class pointer (8 bytes)   │
│ Offset 8-11:  Monitor (4 bytes)          │
│ Offset 12-15: myField = 0 (4 bytes)     │ ← offset 12!
└──────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════

╔════════════════════════════════════════════════════════════════════════════╗
║ PHASE 4: FIELD ACCESS (During Method Execution)                           ║
╚════════════════════════════════════════════════════════════════════════════╝

BYTECODE: getfield #7  (or: putfield #7)

STEP 1: RESOLVE CONSTANT POOL
  constant_pool[7] is ALREADY RESOLVED (from linking phase)
  {
    field_offset: 12  ← CACHED FROM CLASS LOADING!
  }

STEP 2: GET OBJECT
  obj = stack.pop() = 0x7f8e12345678

STEP 3: CALCULATE FIELD ADDRESS
  ┌──────────────────────────────────────────────┐
  │ address = obj_address + field_offset         │
  │         = 0x7f8e12345678 + 12                │
  │         = 0x7f8e1234568C                     │
  └──────────────────────────────────────────────┘

STEP 4: READ or WRITE
  getfield:  value = *(int*)0x7f8e1234568C
  putfield:  *(int*)0x7f8e1234568C = new_value

PERFORMANCE
  No string lookup! No hashtable! No search!
  Just: arithmetic (1 cycle) + memory read (3 cycles) = ~5 nanoseconds

═══════════════════════════════════════════════════════════════════════════════

╔════════════════════════════════════════════════════════════════════════════╗
║ KEY INSIGHT: WHY THIS MATTERS                                             ║
╚════════════════════════════════════════════════════════════════════════════╝

PROBLEM:
  If we looked up field name as a string every time, it would be slow!
  lookup("myField") → hashtable → 10+ cycles per access

SOLUTION:
  Calculate offset ONCE at class loading
  Then use offset for ALL future accesses
  offset arithmetic → 1 cycle!

TRADE-OFF:
  Cost: Small CPU work during class loading (once)
  Benefit: Fast field access repeated billions of times
  Result: 5x performance improvement!

═══════════════════════════════════════════════════════════════════════════════

╔════════════════════════════════════════════════════════════════════════════╗
║ SUMMARY: THE THREE OFFSET TYPES                                           ║
╚════════════════════════════════════════════════════════════════════════════╝

1. FIELD OFFSET (example: 12 bytes from object start)
   ├─ Calculated: at class loading
   ├─ Used for: field access (getfield/putfield)
   ├─ Performance: O(1) - just arithmetic
   └─ Example: myField @ offset 12

2. BYTECODE OFFSET (example: instruction at byte 0, 1, 4, 7)
   ├─ Calculated: during method parsing
   ├─ Used for: debugging, exception handling
   ├─ Performance: not critical
   └─ Example: aload_0 @ offset 0

3. VTABLE INDEX (example: method at slot 11)
   ├─ Calculated: at class loading
   ├─ Used for: virtual method dispatch
   ├─ Performance: O(1) - array lookup
   └─ Example: printField @ vtable[11]

═══════════════════════════════════════════════════════════════════════════════

╔════════════════════════════════════════════════════════════════════════════╗
║ MEMORY LAYOUT VISUALIZATION                                               ║
╚════════════════════════════════════════════════════════════════════════════╝

INSTANCE IN MEMORY:

Instance Address: 0x7f8e12345678

  ┌────────────────────────────────────────┐
  │ Bytes 0-7                              │
  │ 0x7f8c92c50000                         │
  │ (SimpleExample.class pointer)          │
  ├────────────────────────────────────────┤ offset 8
  │ Bytes 8-11                             │
  │ 0x00000000                             │
  │ (Monitor lock)                         │
  ├────────────────────────────────────────┤ offset 12
  │ Bytes 12-15                            │ ← FIELD OFFSET!
  │ 0x0000002A (42)                        │
  │ (myField value)                        │
  ├────────────────────────────────────────┤
  │ Total: 16 bytes                        │
  └────────────────────────────────────────┘

TO ACCESS MYFIELD:
  address = 0x7f8e12345678 + 12
          = 0x7f8e1234568C
  value = *(int*)address = 42

═══════════════════════════════════════════════════════════════════════════════

╔════════════════════════════════════════════════════════════════════════════╗
║ COMPLETE INFORMATION FLOW                                                  ║
╚════════════════════════════════════════════════════════════════════════════╝

SOURCE CODE
    ↓
    │ (javac compilation)
    ↓
.CLASS FILE (binary format)
    ├─ Constant Pool (symbolic refs)
    ├─ Fields Section (names, types)
    └─ Methods Section (bytecode)
    ↓
    │ (JVM class loading & linking)
    ↓
CLASS OBJECT (in-memory metadata)
    ├─ fields[].offset calculated        ← KEY!
    ├─ constant_pool[] entries resolved   ← KEY!
    ├─ methods[] with bytecode
    └─ vtable[] for polymorphism
    ↓
    │ (new SimpleExample())
    ↓
INSTANCE (in heap memory)
    ├─ Header (class pointer, monitor)
    └─ Fields (at calculated offsets)
    ↓
    │ (bytecode execution)
    ↓
FIELD ACCESS (getfield/putfield)
    └─ Uses pre-calculated offset
       for O(1) performance

═══════════════════════════════════════════════════════════════════════════════

For detailed information, see:
  - LINKING_PHASE_DETAILED.md
  - CLASS_OBJECT_CREATION.md
  - FIELD_METHOD_OFFSET_CALCULATION.md
  - MEMORY_LAYOUT_DETAILED.md
  - COMPLETE_GUIDE_INDEX.md

